// -*- Java -*- This Cup file was machine-generated by BNFC
package Sample;

parser code {:
  public Sample.Absyn.Expr pExpr() throws Exception
  {
	java_cup.runtime.Symbol res = parse();
	return (Sample.Absyn.Expr) res.value;
  }

public <B,A extends java.util.LinkedList<? super B>> A cons_(B x, A xs) { xs.addFirst(x); return xs; }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
	report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
	throw new Exception("Unrecoverable Syntax Error");
}

:}

nonterminal Sample.Absyn.Expr Expr;
nonterminal Sample.Absyn.Assignment_op Assignment_op;
nonterminal Sample.Absyn.Dec Dec;
nonterminal Sample.Absyn.Type Type;
nonterminal Sample.Absyn.FieldTypeExpr FieldTypeExpr;

terminal _SYMB_0;    //   :
terminal _SYMB_1;    //   =
terminal _SYMB_2;    //   !
terminal _SYMB_3;    //   0
terminal _SYMB_4;    //   (
terminal _SYMB_5;    //   )
terminal _SYMB_6;    //   and
terminal _SYMB_7;    //   boolean
terminal _SYMB_8;    //   double
terminal _SYMB_9;    //   else
terminal _SYMB_10;    //   end
terminal _SYMB_11;    //   false
terminal _SYMB_12;    //   if
terminal _SYMB_13;    //   integer
terminal _SYMB_14;    //   iszero
terminal _SYMB_15;    //   or
terminal _SYMB_16;    //   pred
terminal _SYMB_17;    //   string
terminal _SYMB_18;    //   succ
terminal _SYMB_19;    //   then
terminal _SYMB_20;    //   true
terminal _SYMB_21;    //   void





terminal String _IDENT_;



start with Expr;


Expr ::= _IDENT_:p_1  {: RESULT = new Sample.Absyn.Vary(p_1); :} 
  | _SYMB_20  {: RESULT = new Sample.Absyn.ConstTrue(); :}
  | _SYMB_11  {: RESULT = new Sample.Absyn.ConstFalse(); :}
  | _SYMB_12 Expr:p_2 _SYMB_19 Expr:p_4 _SYMB_9 Expr:p_6 _SYMB_10  {: RESULT = new Sample.Absyn.If(p_2,p_4,p_6); :}
  | _IDENT_:p_1 _SYMB_0 Type:p_3 _SYMB_1 Expr:p_5  {: RESULT = new Sample.Absyn.Binding(p_1,p_3,p_5); :}
  | _SYMB_2 Expr:p_2  {: RESULT = new Sample.Absyn.Not(p_2); :}
  | Expr:p_1 _SYMB_6 Expr:p_3  {: RESULT = new Sample.Absyn.And(p_1,p_3); :}
  | Expr:p_1 _SYMB_15 Expr:p_3  {: RESULT = new Sample.Absyn.Or(p_1,p_3); :}
  | _SYMB_3  {: RESULT = new Sample.Absyn.ConstZero(); :}
  | _SYMB_18 Expr:p_2  {: RESULT = new Sample.Absyn.Succ(p_2); :}
  | _SYMB_16 Expr:p_2  {: RESULT = new Sample.Absyn.Pred(p_2); :}
  | _SYMB_14 Expr:p_2  {: RESULT = new Sample.Absyn.IsZero(p_2); :}
  | _IDENT_:p_1  {: RESULT = new Sample.Absyn.Var(p_1); :}
  | Expr:p_1 Expr:p_2  {: RESULT = new Sample.Absyn.Application(p_1,p_2); :}
  | _SYMB_4 Expr:p_2 _SYMB_5  {: RESULT = p_2; :}
;
Assignment_op ::= _SYMB_1  {: RESULT = new Sample.Absyn.Assign(); :} 
;
Dec ::= _IDENT_:p_1 _SYMB_0 Type:p_3  {: RESULT = new Sample.Absyn.Declarators(p_1,p_3); :} 
;
Type ::= _SYMB_17  {: RESULT = new Sample.Absyn.StringType(); :} 
  | _SYMB_7  {: RESULT = new Sample.Absyn.BoolType(); :}
  | _SYMB_21  {: RESULT = new Sample.Absyn.UnitType(); :}
  | _SYMB_13  {: RESULT = new Sample.Absyn.IntType(); :}
  | _SYMB_8  {: RESULT = new Sample.Absyn.DoubleType(); :}
;
FieldTypeExpr ::= _IDENT_:p_1 _SYMB_0 Type:p_3  {: RESULT = new Sample.Absyn.FieldType(p_1,p_3); :} 
;

